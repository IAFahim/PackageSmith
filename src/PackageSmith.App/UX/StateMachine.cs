using System;
using System.IO;
using System.Linq;
using Spectre.Console;
using PackageSmith.App.Bridges;
using PackageSmith.Data.State;
using PackageSmith.Data.Types;
using PackageSmith.Core.Logic;

namespace PackageSmith.App.UX;

public static class StateMachine
{
	public static int Run()
	{
		while (true)
		{
			var choice = AnsiConsole.Prompt(
				new SelectionPrompt<string>()
					.AddChoices(new[] { "New Package", "Template Harvester", "Browse Templates", "Exit" }));

			switch (choice)
			{
				case "New Package": NewPackageFlow(); break;
				case "Template Harvester": TemplateHarvesterFlow(); break;
				case "Browse Templates": BrowseTemplatesFlow(); break;
				case "Exit": return 0;
			}
		}
	}

	private static void ShowBanner()
	{
		AnsiConsole.MarkupLine("[bold cyan]â—†[/] [bold white]PackageSmith[/]");
		AnsiConsole.MarkupLine("[dim]Unity Package Scaffolding[/]\n");
	}

	private static void NewPackageFlow()
	{
		AnsiConsole.MarkupLine("[bold white]New Package[/]\n");

		// Ask user to choose creation method
		var method = AnsiConsole.Prompt(
			new SelectionPrompt<string>()
				.AddChoices(new[] { "From Template", "From Scratch" }));

		if (method == "From Template")
		{
			NewPackageFromTemplateFlow();
			return;
		}

		NewPackageFromScratchFlow(); // Original flow - from scratch
	}

	private static void NewPackageFromTemplateFlow()
	{
		AnsiConsole.MarkupLine("\n[dim]Create from harvested template[/]\n");

		var name = AnsiConsole.Ask<string>("[dim]Package name[/] (e.g. [cyan]com.studio.tool[/]):");

		var templatesDir = Path.Combine(GetAppDataPath(), "PackageSmith", "Templates"); // Get available templates
		var templateName = "From Scratch"; // default

		if (Directory.Exists(templatesDir))
		{
			var templates = Directory.GetDirectories(templatesDir)
				.Select(Path.GetFileName)
				.Where(x => x != null)
				.Select(x => x!)
				.OrderBy(x => x)
				.ToList();

			if (templates.Count > 0)
			{
				templateName = AnsiConsole.Prompt(
					new SelectionPrompt<string>()
						.Title("Select template:")
						.AddChoices(templates));
			}
			else
			{
				AnsiConsole.MarkupLine("\n[dim]No templates found. Creating from scratch...[/]\n");
				NewPackageFromScratchFlow(name);
				return;
			}
		}

		var templatePath = Path.Combine(templatesDir, templateName ?? string.Empty);
		var outputPath = Path.Combine(Environment.CurrentDirectory, name);

		if (!TemplateGeneratorLogic.TryGenerateFromTemplate(templatePath, outputPath, name, out var fileCount))
		{
			AnsiConsole.MarkupLine("\n[red]Error:[/] Failed to generate from template");
			Console.ReadLine();
			return;
		}

		GitLogic.TryInitGit(outputPath, out var gitInit);

		AnsiConsole.MarkupLine($"\n[green]Success:[/] Created {fileCount} files from '[cyan]{templateName}[/]'");
		AnsiConsole.MarkupLine(gitInit ? "[green]git initialized[/]" : "[dim]git init skipped[/]");
		AnsiConsole.MarkupLine("\n[bold green]Done[/]. Press Enter.");
		Console.ReadLine();
	}

	private static void NewPackageFromScratchFlow(string? name = null)
	{
		AnsiConsole.MarkupLine("\n[dim]Create from scratch[/]\n");

		name ??= AnsiConsole.Ask<string>("[dim]Package name[/] (e.g. [cyan]com.studio.tool[/]):");
		var parts = name.Split('.');
		var display = AnsiConsole.Ask<string>("[dim]Display name[/]:", parts.Length > 0 ? parts[^1] : name);

		var template = AnsiConsole.Prompt(
			new SelectionPrompt<TemplateType>()
				.AddChoices(TemplateType.None, TemplateType.MonoBehaviour, TemplateType.EcsFull));

		GitLogic.TryGetGitConfig(out var gitUser, out var _);
		var defaultCompany = !string.IsNullOrEmpty(gitUser) ? gitUser : "YourCompany";

		var package = new PackageState
		{
			PackageName = name,
			DisplayName = display,
			Description = "Generated by PackageSmith",
			OutputPath = Environment.CurrentDirectory,
			CompanyName = defaultCompany,
			SelectedTemplate = template,
			EcsPreset = new EcsPresetState { EnableEntities = template == TemplateType.EcsFull },
			SelectedModules = PackageModuleType.Runtime | PackageModuleType.Editor
		};

		var bridge = new PackageBridge();
		if (bridge.TryCreate(in package))
		{
			PackageLogic.CombinePath(package.OutputPath, package.PackageName, out var fullPath);
			GitLogic.TryInitGit(fullPath, out var gitInit);

			AnsiConsole.MarkupLine(gitInit
				? "[green]git initialized[/]"
				: "[dim]git init skipped[/]");

			AnsiConsole.MarkupLine("\n[bold green]Done[/]. Press Enter.");
			Console.ReadLine();
		}
	}

	private static void TemplateHarvesterFlow()
	{
		AnsiConsole.MarkupLine("[bold white]Template Harvester[/]\n");
		AnsiConsole.MarkupLine("[dim]Convert an existing package into a reusable template.[/]\n");

		var sourcePath = AnsiConsole.Ask<string>("[dim]Source package path[/]:", Environment.CurrentDirectory);
		var templateName = AnsiConsole.Ask<string>("[dim]Template name[/]:", "Custom.Template");

		if (!Directory.Exists(sourcePath))
		{
			AnsiConsole.MarkupLine("\n[red]Error:[/] Path does not exist.");
			Console.ReadLine();
			return;
		}

		var packageJsonPath = Path.Combine(sourcePath, "package.json");
		if (!File.Exists(packageJsonPath))
		{
			AnsiConsole.MarkupLine("\n[red]Error:[/] No package.json found.");
			Console.ReadLine();
			return;
		}

		var packageName = ExtractPackageName(packageJsonPath);
		var templatesDir = Path.Combine(GetAppDataPath(), "PackageSmith", "Templates", templateName);

		AnsiConsole.MarkupLine($"\n[dim]Harvesting...[/]");

		if (TemplateHarvesterLogic.TryHarvest(sourcePath, templatesDir, packageName, out var count))
		{
			var manifestPath = Path.Combine(templatesDir, ".template.json");
			var manifest = $"{{\"id\":\"{templateName}\",\"sourcePackage\":\"{packageName}\",\"fileCount\":{count}}}";
			File.WriteAllText(manifestPath, manifest);

			AnsiConsole.MarkupLine($"[green]Success![/] Harvested {count} files.");
			AnsiConsole.MarkupLine($"[dim]Template saved to:[/] [blue]{templatesDir}[/]");
		}
		else
		{
			AnsiConsole.MarkupLine("[red]Harvest failed.[/]");
		}

		AnsiConsole.MarkupLine("\nPress Enter.");
		Console.ReadLine();
	}

	private static void BrowseTemplatesFlow()
	{
		var templatesDir = Path.Combine(GetAppDataPath(), "PackageSmith", "Templates");

		if (!Directory.Exists(templatesDir))
		{
			AnsiConsole.MarkupLine("[dim]No templates found.[/]\nPress Enter.");
			Console.ReadLine();
			return;
		}

		var templates = Directory.GetDirectories(templatesDir);
		if (templates.Length == 0)
		{
			AnsiConsole.MarkupLine("[dim]No templates found.[/]\nPress Enter.");
			Console.ReadLine();
			return;
		}

		while (true)
		{
			AnsiConsole.Clear();
			AnsiConsole.MarkupLine("[bold white]Browse Templates[/]\n");

			var table = new Table();
			table.Border(TableBorder.Minimal);
			table.AddColumn("[dim]Name[/]");
			table.AddColumn("[dim]Files[/]");
			table.AddColumn("[dim]Source[/]");

			foreach (var t in templates.OrderBy(x => x))
			{
				var name = Path.GetFileName(t);
				var manifestPath = Path.Combine(t, ".template.json");
				var filesCount = Directory.GetFiles(t, "*", SearchOption.AllDirectories).Length;
				var source = "Unknown";

				if (File.Exists(manifestPath))
				{
					try
					{
						var manifest = System.Text.Json.JsonDocument.Parse(File.ReadAllText(manifestPath));
						if (manifest.RootElement.TryGetProperty("sourcePackage", out var src))
							source = src.GetString() ?? "Unknown";
						if (manifest.RootElement.TryGetProperty("fileCount", out var fc))
							filesCount = fc.GetInt32();
					}
					catch { /* Ignore */ }
				}

				table.AddRow($"[cyan]{name}[/]", $"[white]{filesCount}[/]", $"[dim]{source}[/]");
			}

			AnsiConsole.Write(table);

			var choice = AnsiConsole.Prompt(
				new SelectionPrompt<string>()
					.AddChoices(new[] { "Use Template", "Back" }));

			if (choice == "Back") break;

			var selectedTemplate = AnsiConsole.Prompt(
				new SelectionPrompt<string>()
					.Title("Select template:")
					.AddChoices(templates.Select(Path.GetFileName).Where(x => x != null).Select(x => x!)));

			var packageName = AnsiConsole.Ask<string>("\n[dim]Package name[/]:"); // Ask for package name and create
			var fullOutputPath = Path.Combine(Environment.CurrentDirectory, packageName);

			if (TemplateGeneratorLogic.TryGenerateFromTemplate(
				Path.Combine(templatesDir, selectedTemplate ?? string.Empty),
				fullOutputPath,
				packageName,
				out var fileCount))
			{
				GitLogic.TryInitGit(fullOutputPath, out var gitInit);
				AnsiConsole.MarkupLine($"\n[green]Success:[/] Created {fileCount} files");
				if (gitInit) AnsiConsole.MarkupLine("[green]git initialized[/]");
			}
			else
			{
				AnsiConsole.MarkupLine("\n[red]Error:[/] Failed to create package");
			}

			AnsiConsole.MarkupLine("\nPress Enter.");
			Console.ReadLine();
		}
	}

	private static string ExtractPackageName(string jsonPath)
	{
		var content = File.ReadAllText(jsonPath);
		var doc = System.Text.Json.JsonDocument.Parse(content);
		if (doc.RootElement.TryGetProperty("name", out var prop))
			return prop.GetString() ?? "unknown";
		return "unknown";
	}

	private static string GetAppDataPath()
	{
		if (OperatingSystem.IsWindows())
			return Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData));
		if (OperatingSystem.IsMacOS())
			return Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), "Library", "Application Support");
		return Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), ".local", "share");
	}
}
